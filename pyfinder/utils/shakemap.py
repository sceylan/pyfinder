# -*- coding: utf-8 -*-
""" Module to manage the shakemap input files from FinDer solution."""

# ShakeMapExporter: exports ShakeMap-compatible event.xml and stationlist.json from a FinderSolution
import os
import json
import tempfile
from datetime import datetime, timezone
from xml.etree.ElementTree import Element, ElementTree
import subprocess
from finderutils import FinderSolution
import logging

# --------------------------------------------
# ShakeMapExporter utility for exporting ShakeMap-compatible files
# --------------------------------------------
class ShakeMapExporter:
    """
    A utility class to export ShakeMap-compatible input files from a FinderSolution.
    It generates event.xml and stationlist.json in a temporary or specified directory.
    """

    def __init__(self, solution: FinderSolution, output_dir: str = None):
        # Validate that the solution is a FinderSolution instance
        if solution is None:
            logging.error("No solution provided to ShakeMapExporter.")
        elif not isinstance(solution, FinderSolution):
            logging.error("Provided solution is not a FinderSolution instance: {}".format(FinderSolution.__module__))
            logging.error("Provided solution is not a FinderSolution instance: {}".format(type(solution)))
        
        logging.info("ShakeMapExporter initialized with FinderSolution.")
        self.solution = solution

        # Create a default output directory in the user's home if not specified
        self.output_dir = output_dir or os.path.join(
            os.path.expanduser("~"),
            "shakemap_profiles", "default", "data",
            self.solution.get_event_id() or self.solution.get_finder_event_id(),
            "current"
        )
        os.makedirs(self.output_dir, exist_ok=True)
        logging.info(f"ShakeMapExporter output directory: {self.output_dir}")

    def export_all(self):
        """Exports both event.xml and stationlist.json as well as rupture.json """
        event_path = self._write_event_xml()
        station_path = self._write_stationlist_json()
        rupture_path = self._write_rupture_json()
        
        # Ensure products dir exists
        products_dir = os.path.join(self.output_dir, "products")
        os.makedirs(products_dir, exist_ok=True)

        logging.info(f"ShakeMap files written to {self.output_dir}")

        return {
            "event.xml": event_path,
            "stationlist.json": station_path,
            "rupture.json": rupture_path,
            "output_dir": self.output_dir
        }


    def _write_rupture_json(self):
        rupture = self.solution.get_rupture()
        if rupture is None:
            return None

        # Create closed loop of points for MultiPolygon
        coords = [[lon, lat, depth] for lat, lon, depth in rupture.get_points()]
        if coords and coords[0] != coords[-1]:
            coords.append(coords[0])  # Ensure loop is closed

        rupture_data = {
            "type": "FeatureCollection",
            "metadata": {
                "reference": "Generated by FinDer during pyfinder runtime"
            },
            "features": [{
                "type": "Feature",
                "properties": {
                    "rupture type": "rupture extent"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[coords]]
                }
            }]
        }

        path = os.path.join(self.output_dir, "rupture.json")
        with open(path, "w", encoding="utf-8") as f:
            json.dump(rupture_data, f, indent=2)
        return path
    

    
    def _write_event_xml(self):
        event = self.solution.get_event()
        root = Element("earthquake")
        root.set("event_id", self.solution.get_event_id() or self.solution.get_finder_event_id())
        root.set("id", self.solution.get_finder_event_id() or self.solution.get_event_id())
        root.set("netid", "FinDer")
        root.set("mag", str(event.get_magnitude()))
        root.set("lat", str(event.get_latitude()))
        root.set("lon", str(event.get_longitude()))
        root.set("depth", str(event.get_depth()))
        root.set("time", datetime.fromtimestamp(event.get_origin_time_epoch(), tz=timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"))
        root.set("locstring", "FinDer Origin")
        root.set("event_type", "ACTUAL")

        tree = ElementTree(root)
        path = os.path.join(self.output_dir, "event.xml")
        tree.write(path, encoding="utf-8", xml_declaration=True)
        return path

    def _write_stationlist_json(self):
        features = []

        if self.solution.get_channels() is None:
            logging.error("No channels found in the solution.")

        for ch in self.solution.get_channels():
            feature = {
                "type": "Feature",
                "id": f"{ch.get_network_code()}.{ch.get_station_code()}",
                "geometry": {
                    "type": "Point",
                    "coordinates": [ch.get_longitude(), ch.get_latitude()]
                },
                "properties": {
                    "network": ch.get_network_code(),
                    "netid": ch.get_network_code(),
                    "intensity_flag": "",
                    "mmi_from_pgm": [],
                    "commType": "UNK",
                    "intensity": None,
                    "pgv": None,
                    "source": ch.get_network_code(),
                    "instrumentType": "OBSERVED",
                    "station_type": "seismic",
                    "code": f"{ch.get_network_code()}.{ch.get_station_code()}",
                    "name": ch.get_station_code(),
                    "pga": ch.get_pga(),
                    "intensity_stddev": None,
                    # "distance": ch.get_distance_km() or 0.0,
                    # "distances": {
                    #     "ry0": ch.get_distance_km() or 0.0,
                    #     "rrup": ch.get_distance_km() or 0.0,
                    #     "rjb": ch.get_distance_km() or 0.0,
                    #     "rx": 0.0,
                    #     "rhypo": ch.get_distance_km() or 0.0
                    # },
                    "location": ch.get_location_code(),
                    "channels": [
                        {
                            "name": f"{ch.get_location_code()}.{ch.get_channel_code()}",
                            "amplitudes": [
                                {
                                    "name": "pga",
                                    "value": ch.get_pga(),
                                    "units": "cm/s/s",
                                    "flag": "0",
                                    "ln_sigma": 0
                                }
                            ] if ch.get_pga() is not None else []
                        }
                    ],
                    "predictions": []
                }
            }
            features.append(feature)

        collection = {
            "type": "FeatureCollection",
            "features": features,
            "metadata": {
                "created": datetime.utcnow().isoformat() + "Z",
                "source": "pyfinder"
            }
        }

        path = os.path.join(self.output_dir, "stationlist.json")
        with open(path, "w", encoding="utf-8") as f:
            json.dump(collection, f, indent=2)
        return path


# --------------------------------------------
# ShakeMapTrigger utility for running ShakeMap
# --------------------------------------------
class ShakeMapTrigger:
    """
    Utility class to trigger ShakeMap from a set of exported files.
    """

    def __init__(self, event_id, event_xml, stationlist_path, rupture_path=None, shake_cmd='shake', logger=None):
        self.event_id = event_id
        self.event_xml = event_xml
        self.stationlist_path = stationlist_path
        self.rupture_path = rupture_path
        self.shake_cmd = shake_cmd
        self.logger = logger or logging.getLogger(__name__)

    def validate_inputs(self):
        if not os.path.isfile(self.event_xml):
            raise FileNotFoundError(f"Missing event file: {self.event_xml}")
        if not os.path.isfile(self.stationlist_path):
            raise FileNotFoundError(f"Missing stationlist file: {self.stationlist_path}")
        if self.rupture_path and not os.path.isfile(self.rupture_path):
            raise FileNotFoundError(f"Missing rupture file: {self.rupture_path}")

    def run(self):
        self.validate_inputs()
        cmd = [
            self.shake_cmd,
            "--force",  # force overwrite of existing files
            "-d", self.event_id,  # positional argument for event ID
            "select", "assemble",
            "-c", "pyFinder",
            "model", "contour", "mapping", "stations",  "gridxml"
        ]

        self.logger.info(f"Running ShakeMap: {' '.join(cmd)}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            self.logger.info("ShakeMap triggered successfully.")
            self.logger.debug(result.stdout)
        except subprocess.CalledProcessError as e:
            self.logger.error(f"ShakeMap failed: {e.stderr}")
            raise


